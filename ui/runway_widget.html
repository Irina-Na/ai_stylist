<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Runway Director</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bodoni+Moda:opsz,wght@6..96,500;6..96,700&family=Space+Grotesk:wght@400;500;600&display=swap');

        :root {
            --bg-0: #0b0f16;
            --bg-1: #0f1622;
            --bg-2: #141c2a;
            --surface: rgba(16, 22, 33, 0.8);
            --ink-0: #f3f6fb;
            --ink-1: #b8c2d6;
            --ink-2: #7f8aa5;
            --edge: #1f2a3a;
            --accent: #7cc5ff;
            --accent-2: #5ef2d6;
            --font-display: 'Bodoni Moda', 'Playfair Display', serif;
            --font-ui: 'Space Grotesk', 'IBM Plex Sans', 'Noto Sans', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-ui);
            background: radial-gradient(1200px 600px at 15% -10%, rgba(124, 197, 255, 0.14), transparent 60%),
                        radial-gradient(900px 500px at 90% 0%, rgba(94, 242, 214, 0.12), transparent 58%),
                        linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 55%, var(--bg-0) 100%);
            color: var(--ink-0);
        }

        #app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #topbar {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 24px;
            padding: 22px 28px;
            border-bottom: 1px solid var(--edge);
            background: rgba(10, 14, 22, 0.9);
            backdrop-filter: blur(8px);
        }

        .brand {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #cover-title {
            font-family: var(--font-display);
            font-size: 28px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #cover-subtitle {
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--ink-2);
        }

        #cover-badges {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .cover-badge {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid var(--edge);
            font-size: 10px;
            letter-spacing: 1.4px;
            text-transform: uppercase;
            color: var(--ink-1);
            background: rgba(16, 22, 33, 0.8);
        }

        #runway-container {
            position: relative;
            width: 100%;
            height: 620px;
            overflow: hidden;
            background: radial-gradient(800px 320px at 50% 15%, rgba(124, 197, 255, 0.18), transparent 60%),
                        radial-gradient(700px 240px at 60% 20%, rgba(94, 242, 214, 0.12), transparent 62%),
                        linear-gradient(180deg, #0b0f16 0%, #0f1622 100%);
        }

        #runway-container::before,
        #runway-container::after {
            content: "";
            position: absolute;
            width: 420px;
            height: 420px;
            background: radial-gradient(circle, rgba(124, 197, 255, 0.25), transparent 70%);
            filter: blur(12px);
            top: -120px;
            z-index: 1;
            animation: glowPulse 5s ease-in-out infinite;
        }

        #runway-container::after {
            left: auto;
            right: -80px;
            background: radial-gradient(circle, rgba(94, 242, 214, 0.22), transparent 70%);
            animation-delay: 1.2s;
        }

        #runway-container::before {
            left: -80px;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 2;
        }

        .look-label {
            position: absolute;
            left: 24px;
            padding: 6px 12px;
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--ink-1);
            background: rgba(16, 22, 33, 0.8);
            border: 1px solid var(--edge);
            border-radius: 999px;
            z-index: 5;
            backdrop-filter: blur(8px);
        }

        .look-1 {
            top: 24px;
        }

        .look-2 {
            top: 56px;
        }

        .item-card {
            position: absolute;
            width: 176px;
            background: rgba(16, 22, 33, 0.88);
            border: 1px solid var(--edge);
            border-radius: 16px;
            overflow: hidden;
            transition: box-shadow 0.3s ease, transform 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 12px 26px rgba(3, 8, 16, 0.5);
            animation: cardFloat 0.8s ease both;
            z-index: 4;
        }

        .item-card:hover {
            transform: translateY(-6px);
            box-shadow: 0 18px 40px rgba(6, 12, 22, 0.6);
        }

        .item-card img {
            width: 100%;
            height: 160px;
            object-fit: cover;
            background: #0f141f;
        }

        .item-card-label {
            padding: 10px 12px;
            color: var(--ink-1);
            font-size: 10px;
            text-align: center;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--ink-2);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 3px;
            z-index: 3;
        }

        @keyframes glowPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes cardFloat {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 720px) {
            #topbar {
                flex-direction: column;
                align-items: flex-start;
            }

            #runway-container {
                height: 520px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header id="topbar">
            <div class="brand">
                <div id="cover-title">Runway</div>
                <div id="cover-subtitle">Try on your new outfit</div>
            </div>
            <div id="cover-badges"></div>
            
        </header>
        <main id="runway-container">
            <div id="canvas-container"></div>
            <div class="look-label look-1">Look 1</div>
            <div class="look-label look-2">Look 2</div>
            <div id="loading">Loading runway...</div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let runway, particles, spotlights = [];
        let items = [];
        const RENDER_3D_LOOKS = false;
        let sceneConfig = {
            theme: 'gallery_night',
            lighting: 'cool',
            atmosphere: 'gallery haze',
            fogDensity: 0.02,
            fogColor: 0x0b0f16,
            backgroundColor: 0x0b0f16,
            spotlightIntensity: 1.1,
            spotlightColor: 0x9cd6ff,
            particleCount: 320,
            particleSpeed: 0.0008,
            cameraDistance: 11,
            cameraHeight: 4.2
        };

        // Initialize scene
        function init() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(sceneConfig.backgroundColor);
            scene.fog = new THREE.FogExp2(sceneConfig.fogColor, sceneConfig.fogDensity);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, sceneConfig.cameraHeight, sceneConfig.cameraDistance);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Create runway
            createRunway();
            
            // Create lighting
            createLighting();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createRunway() {
            // Main runway platform
            const runwayGeometry = new THREE.BoxGeometry(8, 0.2, 20);
            const runwayMaterial = new THREE.MeshStandardMaterial({
                color: 0x0f1724,
                metalness: 0.45,
                roughness: 0.25,
                emissive: 0x0a101a,
                emissiveIntensity: 0.7
            });
            runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.position.y = -0.1;
            runway.receiveShadow = true;
            scene.add(runway);

            const glowGeometry = new THREE.PlaneGeometry(6.2, 18);
            const glowMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d1420,
                emissive: 0x1b2a3d,
                emissiveIntensity: 0.9,
                transparent: true,
                opacity: 0.9
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotation.x = -Math.PI / 2;
            glow.position.y = 0.01;
            scene.add(glow);
        }

        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x8aa2c8, 0.35);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0x9cd6ff, 0x06080b, 0.45);
            scene.add(hemiLight);
            
            // Spotlights
            const spotlightPositions = [
                { x: -5, y: 8, z: 6 },
                { x: 5, y: 8, z: -6 }
            ];
            
            spotlightPositions.forEach(pos => {
                const spotlight = new THREE.SpotLight(
                    sceneConfig.spotlightColor,
                    sceneConfig.spotlightIntensity
                );
                spotlight.position.set(pos.x, pos.y, pos.z);
                spotlight.angle = Math.PI / 6;
                spotlight.penumbra = 0.7;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 1024;
                spotlight.shadow.mapSize.height = 1024;
                scene.add(spotlight);
                spotlights.push(spotlight);
            });
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0x9cd6ff, 0.35);
            rimLight.position.set(0, 6, -10);
            scene.add(rimLight);
        }

        function createParticles() {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(sceneConfig.particleCount * 3);
            
            for (let i = 0; i < sceneConfig.particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;
                positions[i + 1] = Math.random() * 10;
                positions[i + 2] = (Math.random() - 0.5) * 20;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: sceneConfig.spotlightColor || 0x9cd6ff,
                size: 0.035,
                transparent: true,
                opacity: 0.55
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        function addItemsToRunway(itemData) {
            // Clear existing items
            items.forEach(item => {
                if (item.mesh) {
                    scene.remove(item.mesh);
                }
                const card = document.getElementById(`card-${item.id}`);
                if (card) card.remove();
            });
            items = [];
            
            const textureLoader = new THREE.TextureLoader();

            // Group items by look_label to make separate rows
            const grouped = {};
            itemData.forEach(item => {
                const label = item.look_label || 'Look';
                if (!grouped[label]) grouped[label] = [];
                grouped[label].push(item);
            });

            const rowZ = {
                'Look 1': 4,
                'Look 2': -4
            };

            const rowX = {
                'Look 1': -2.5,
                'Look 2': 2.5
            };

            const orderedLabels = Object.keys(grouped);
            let orderedItems = [];
            orderedLabels.forEach(label => {
                orderedItems = orderedItems.concat(grouped[label]);
            });

            const positionsByItemId = new Map();
            orderedLabels.forEach(label => {
                const rowItems = grouped[label];
                const z = rowZ[label] !== undefined ? rowZ[label] : 0;
                const count = rowItems.length;
                const xPositions = [];
                if (count === 1) {
                    xPositions.push(rowX[label] !== undefined ? rowX[label] : 0);
                } else {
                    const span = 6;
                    const step = span / (count - 1);
                    for (let i = 0; i < count; i++) {
                        xPositions.push(-span / 2 + step * i);
                    }
                }
                rowItems.forEach((item, idx) => {
                    const key = item.id || `${label}-${idx}`;
                    positionsByItemId.set(key, { x: xPositions[idx], z });
                });
            });

            orderedItems.forEach((item, index) => {
                const key = item.id || `${item.look_label || 'Look'}-${index}`;
                const pos = positionsByItemId.get(key) || { x: 0, z: 0 };
                
                let mesh = null;
                if (RENDER_3D_LOOKS) {
                    // Create 3D representation (plane with texture)
                    const geometry = new THREE.PlaneGeometry(3.2, 3.2);
                    
                    // Use data URI if available, otherwise use URL
                    const imageUrl = item.image_data_uri || item.image_url;
                    
                    let material;
                    if (imageUrl) {
                        const texture = textureLoader.load(imageUrl);
                        material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.95,
                            side: THREE.DoubleSide
                        });
                    } else {
                        // Fallback to white material
                        material = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.9,
                            side: THREE.DoubleSide
                        });
                    }
                    
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(pos.x, 2.0, pos.z);
                    mesh.rotation.y = Math.PI / 4;
                    scene.add(mesh);
                }
                
                items.push({
                    id: item.id || index,
                    mesh: mesh,
                    data: item,
                    pos: { x: pos.x, z: pos.z },
                    basePos: { x: pos.x, z: pos.z },
                    phase: Math.random() * Math.PI * 2
                });
                
                // Create HTML card overlay
                createItemCard(item, pos, index);
            });
        }

        function createItemCard(item, pos, index) {
            const card = document.createElement('div');
            card.className = 'item-card';
            card.id = `card-${item.id || index}`;
            
            const img = document.createElement('img');
            img.src = item.image_data_uri || item.image_url || '';
            img.alt = item.name || 'Item';
            
            const label = document.createElement('div');
            label.className = 'item-card-label';
            if (item.look_label) {
                label.textContent = `${item.look_label} - ${item.category || 'Item'}`;
            } else {
                label.textContent = item.category || 'Item';
            }
            
            card.appendChild(img);
            card.appendChild(label);
            
            // Position card based on 3D position
            updateCardPosition(card, pos);
            
            document.getElementById('runway-container').appendChild(card);
        }

        function updateCardPosition(card, pos) {
            const vector = new THREE.Vector3(pos.x, 1.5, pos.z);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * document.getElementById('canvas-container').clientWidth;
            const y = (-(vector.y * 0.5) + 0.5) * document.getElementById('canvas-container').clientHeight;
            
            const halfWidth = card.offsetWidth / 2;
            const halfHeight = card.offsetHeight / 2;
            card.style.left = `${x - halfWidth}px`;
            card.style.top = `${y - halfHeight}px`;
        }

        function updateScene(config) {
            const normalized = {
                fogDensity: config.fogDensity ?? config.fog_density,
                fogColor: config.fogColor ?? config.fog_color,
                backgroundColor: config.backgroundColor ?? config.background_color,
                spotlightIntensity: config.spotlightIntensity ?? config.spotlight_intensity,
                spotlightColor: config.spotlightColor ?? config.spotlight_color,
                particleCount: config.particleCount ?? config.particle_count,
                particleSpeed: config.particleSpeed ?? config.particle_speed,
                cameraDistance: config.cameraDistance ?? config.camera_distance,
                cameraHeight: config.cameraHeight ?? config.camera_height,
                theme: config.theme,
                lighting: config.lighting,
                atmosphere: config.atmosphere
            };

            // Update scene configuration
            Object.assign(sceneConfig, normalized);
            
            // Update background
            if (normalized.backgroundColor) {
                scene.background = new THREE.Color(normalized.backgroundColor);
            }
            if (normalized.fogColor) {
                scene.fog.color = new THREE.Color(normalized.fogColor);
            }
            if (normalized.fogDensity !== undefined) {
                scene.fog.density = normalized.fogDensity;
            }
            
            // Update spotlights
            if (normalized.spotlightIntensity !== undefined || normalized.spotlightColor) {
                spotlights.forEach(spotlight => {
                    if (normalized.spotlightIntensity !== undefined) {
                        spotlight.intensity = normalized.spotlightIntensity;
                    }
                    if (normalized.spotlightColor) {
                        spotlight.color = new THREE.Color(normalized.spotlightColor);
                    }
                });
            }
            
            // Update particles
            if (normalized.particleCount !== undefined || normalized.particleSpeed !== undefined) {
                if (particles) {
                    scene.remove(particles);
                }
                createParticles();
            }
            
            // Update camera
            if (normalized.cameraDistance !== undefined || normalized.cameraHeight !== undefined) {
                camera.position.set(
                    0, 
                    normalized.cameraHeight || sceneConfig.cameraHeight, 
                    normalized.cameraDistance || sceneConfig.cameraDistance
                );
                camera.lookAt(0, 0, 0);
            }
            
        }

        function updateCover(title, subtitle, badges) {
            document.getElementById('cover-title').textContent = title || 'Runway';
            document.getElementById('cover-subtitle').textContent = subtitle || 'Two looks, one podium';

            const badgeWrap = document.getElementById('cover-badges');
            badgeWrap.innerHTML = '';
            if (badges && badges.length) {
                badges.forEach((badge) => {
                    const el = document.createElement('div');
                    el.className = 'cover-badge';
                    el.textContent = badge;
                    badgeWrap.appendChild(el);
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Animate runway items
            items.forEach((item, index) => {
                const t = Date.now() * 0.001;
                const speed = 0.12;
                const pathStart = -7.5;
                const pathEnd = 6.0;
                const pathLength = pathEnd - pathStart;
                const offset = (index * 0.5) % 1.0;
                const progress = (t * speed + offset) % 1.0;
                const z = pathStart + progress * pathLength;

                const bob = Math.sin(t * 2.0 + item.phase) * 0.06;
                const sway = Math.sin(t * 1.2 + item.phase) * 0.08;

                item.pos.x = item.basePos.x + sway;
                item.pos.z = z;

                if (item.mesh) {
                    item.mesh.position.x = item.pos.x;
                    item.mesh.position.z = item.pos.z;
                    item.mesh.position.y = 2.0 + bob;

                    item.mesh.rotation.y = Math.PI / 4 + Math.sin(t * 1.2 + index) * 0.06;
                }
            });

            updateAllCardPositions();
            
            renderer.render(scene, camera);
        }

        function updateAllCardPositions() {
            items.forEach((item) => {
                const card = document.getElementById(`card-${item.id}`);
                if (card) {
                    updateCardPosition(card, item.pos);
                }
            });
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            updateAllCardPositions();
        }

        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>

