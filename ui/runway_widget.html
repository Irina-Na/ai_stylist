<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Runway Director</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Instrument+Serif:opsz@8..144&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', 'Helvetica Neue', Arial, sans-serif;
            background: #f6f3ee;
            color: #1b1b1b;
        }

        #app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 24px;
            padding: 20px 28px;
            border-bottom: 1px solid #e3ded5;
            background: #f6f3ee;
        }

        .brand {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #cover-title {
            font-family: 'Instrument Serif', 'Times New Roman', serif;
            font-size: 26px;
            letter-spacing: 1px;
        }

        #cover-subtitle {
            font-size: 13px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: #5b554f;
        }

        .prompt {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            max-width: 520px;
        }

        .prompt input {
            flex: 1;
            padding: 12px 14px;
            border: 1px solid #ded7cd;
            border-radius: 10px;
            background: #ffffff;
            font-size: 14px;
        }

        .prompt input:focus {
            outline: none;
            border-color: #111111;
        }

        .prompt button {
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #111111;
            background: #111111;
            color: #f6f3ee;
            font-size: 14px;
            cursor: pointer;
        }

        .prompt button:hover {
            background: #2b2b2b;
        }

        #runway-container {
            position: relative;
            width: 100%;
            height: 600px;
            overflow: hidden;
            background: linear-gradient(180deg, #f6f3ee 0%, #efe9e0 100%);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .look-label {
            position: absolute;
            left: 24px;
            padding: 6px 10px;
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #5b554f;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e1dad0;
            border-radius: 999px;
            z-index: 5;
        }

        .look-1 {
            top: 24px;
        }

        .look-2 {
            top: 56px;
        }

        .item-card {
            position: absolute;
            width: 132px;
            background: rgba(255, 255, 255, 0.96);
            border: 1px solid #e1dad0;
            border-radius: 12px;
            overflow: hidden;
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            backdrop-filter: blur(6px);
        }

        .item-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(0,0,0,0.15);
        }

        .item-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }

        .item-card-label {
            padding: 8px;
            color: #1b1b1b;
            font-size: 11px;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #1b1b1b;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @media (max-width: 720px) {
            #topbar {
                flex-direction: column;
                align-items: stretch;
            }

            .prompt {
                max-width: 100%;
            }

            #runway-container {
                height: 520px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <header id="topbar">
            <div class="brand">
                <div id="cover-title">Runway</div>
                <div id="cover-subtitle">Try on your new outfit</div>
            </div>
            
        </header>
        <main id="runway-container">
            <div id="canvas-container"></div>
            <div class="look-label look-1">Look 1</div>
            <div class="look-label look-2">Look 2</div>
            <div id="loading">Loading runway...</div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let runway, particles, spotlights = [];
        let items = [];
        let sceneConfig = {
            theme: 'minimal',
            lighting: 'soft',
            atmosphere: 'clean',
            fogDensity: 0.01,
            fogColor: 0xf3ede4,
            backgroundColor: 0xf6f3ee,
            spotlightIntensity: 0.6,
            spotlightColor: 0xffffff,
            particleCount: 0,
            particleSpeed: 0.0,
            cameraDistance: 15,
            cameraHeight: 5
        };

        // Initialize scene
        function init() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(sceneConfig.backgroundColor);
            scene.fog = new THREE.FogExp2(sceneConfig.fogColor, sceneConfig.fogDensity);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, sceneConfig.cameraHeight, sceneConfig.cameraDistance);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Create runway
            createRunway();
            
            // Create lighting
            createLighting();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createRunway() {
            // Main runway platform
            const runwayGeometry = new THREE.BoxGeometry(8, 0.2, 20);
            const runwayMaterial = new THREE.MeshStandardMaterial({
                color: 0xe2ddd4,
                metalness: 0.2,
                roughness: 0.6
            });
            runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.position.y = -0.1;
            runway.receiveShadow = true;
            scene.add(runway);
        }

        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // Spotlights
            const spotlightPositions = [
                { x: -5, y: 8, z: 5 },
                { x: 5, y: 8, z: -5 }
            ];
            
            spotlightPositions.forEach(pos => {
                const spotlight = new THREE.SpotLight(
                    sceneConfig.spotlightColor,
                    sceneConfig.spotlightIntensity
                );
                spotlight.position.set(pos.x, pos.y, pos.z);
                spotlight.angle = Math.PI / 6;
                spotlight.penumbra = 0.7;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 1024;
                spotlight.shadow.mapSize.height = 1024;
                scene.add(spotlight);
                spotlights.push(spotlight);
            });
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(0, 5, -10);
            scene.add(rimLight);
        }

        function createParticles() {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(sceneConfig.particleCount * 3);
            
            for (let i = 0; i < sceneConfig.particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;
                positions[i + 1] = Math.random() * 10;
                positions[i + 2] = (Math.random() - 0.5) * 20;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        function addItemsToRunway(itemData) {
            // Clear existing items
            items.forEach(item => {
                scene.remove(item.mesh);
                const card = document.getElementById(`card-${item.id}`);
                if (card) card.remove();
            });
            items = [];
            
            const textureLoader = new THREE.TextureLoader();

            // Group items by look_label to make separate rows
            const grouped = {};
            itemData.forEach(item => {
                const label = item.look_label || 'Look';
                if (!grouped[label]) grouped[label] = [];
                grouped[label].push(item);
            });

            const rowZ = {
                'Look 1': 4,
                'Look 2': -4
            };

            const rowX = {
                'Look 1': -2.5,
                'Look 2': 2.5
            };

            const orderedLabels = Object.keys(grouped);
            let orderedItems = [];
            orderedLabels.forEach(label => {
                orderedItems = orderedItems.concat(grouped[label]);
            });

            const positionsByItemId = new Map();
            orderedLabels.forEach(label => {
                const rowItems = grouped[label];
                const z = rowZ[label] !== undefined ? rowZ[label] : 0;
                const count = rowItems.length;
                const xPositions = [];
                if (count === 1) {
                    xPositions.push(rowX[label] !== undefined ? rowX[label] : 0);
                } else {
                    const span = 6;
                    const step = span / (count - 1);
                    for (let i = 0; i < count; i++) {
                        xPositions.push(-span / 2 + step * i);
                    }
                }
                rowItems.forEach((item, idx) => {
                    const key = item.id || `${label}-${idx}`;
                    positionsByItemId.set(key, { x: xPositions[idx], z });
                });
            });

            orderedItems.forEach((item, index) => {
                const key = item.id || `${item.look_label || 'Look'}-${index}`;
                const pos = positionsByItemId.get(key) || { x: 0, z: 0 };
                
                // Create 3D representation (plane with texture)
                const geometry = new THREE.PlaneGeometry(2, 2);
                
                // Use data URI if available, otherwise use URL
                const imageUrl = item.image_data_uri || item.image_url;
                
                let material;
                if (imageUrl) {
                    const texture = textureLoader.load(imageUrl);
                    material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.95,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Fallback to white material
                    material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, 1.5, pos.z);
                mesh.rotation.y = Math.PI / 4;
                scene.add(mesh);
                
                items.push({
                    id: item.id || index,
                    mesh: mesh,
                    data: item,
                    pos: pos
                });
                
                // Create HTML card overlay
                createItemCard(item, pos, index);
            });
        }

        function createItemCard(item, pos, index) {
            const card = document.createElement('div');
            card.className = 'item-card';
            card.id = `card-${item.id || index}`;
            
            const img = document.createElement('img');
            img.src = item.image_data_uri || item.image_url || '';
            img.alt = item.name || 'Item';
            
            const label = document.createElement('div');
            label.className = 'item-card-label';
            if (item.look_label) {
                label.textContent = `${item.look_label} - ${item.category || 'Item'}`;
            } else {
                label.textContent = item.category || 'Item';
            }
            
            card.appendChild(img);
            card.appendChild(label);
            
            // Position card based on 3D position
            updateCardPosition(card, pos);
            
            document.getElementById('runway-container').appendChild(card);
        }

        function updateCardPosition(card, pos) {
            const vector = new THREE.Vector3(pos.x, 1.5, pos.z);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * document.getElementById('canvas-container').clientWidth;
            const y = (-(vector.y * 0.5) + 0.5) * document.getElementById('canvas-container').clientHeight;
            
            const halfWidth = card.offsetWidth / 2;
            const halfHeight = card.offsetHeight / 2;
            card.style.left = `${x - halfWidth}px`;
            card.style.top = `${y - halfHeight}px`;
        }

        function updateScene(config) {
            // Update scene configuration
            Object.assign(sceneConfig, config);
            
            // Update background
            if (config.backgroundColor) {
                scene.background = new THREE.Color(config.backgroundColor);
            }
            if (config.fogColor) {
                scene.fog.color = new THREE.Color(config.fogColor);
            }
            if (config.fogDensity !== undefined) {
                scene.fog.density = config.fogDensity;
            }
            
            // Update spotlights
            if (config.spotlightIntensity !== undefined || config.spotlightColor) {
                spotlights.forEach(spotlight => {
                    if (config.spotlightIntensity !== undefined) {
                        spotlight.intensity = config.spotlightIntensity;
                    }
                    if (config.spotlightColor) {
                        spotlight.color = new THREE.Color(config.spotlightColor);
                    }
                });
            }
            
            // Update particles
            if (config.particleCount !== undefined || config.particleSpeed !== undefined) {
                if (particles) {
                    scene.remove(particles);
                }
                createParticles();
            }
            
            // Update camera
            if (config.cameraDistance !== undefined || config.cameraHeight !== undefined) {
                camera.position.set(
                    0, 
                    config.cameraHeight || sceneConfig.cameraHeight, 
                    config.cameraDistance || sceneConfig.cameraDistance
                );
                camera.lookAt(0, 0, 0);
            }
            
        }

        function updateCover(title, subtitle, badges) {
            document.getElementById('cover-title').textContent = title || 'Runway';
            document.getElementById('cover-subtitle').textContent = subtitle || 'Two looks, one podium';
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Animate runway items
            items.forEach((item, index) => {
                item.mesh.rotation.y = Math.PI / 4 + Math.sin(Date.now() * 0.001 + index) * 0.1;
            });

            updateAllCardPositions();
            
            renderer.render(scene, camera);
        }

        function updateAllCardPositions() {
            items.forEach((item) => {
                const card = document.getElementById(`card-${item.id}`);
                if (card) {
                    updateCardPosition(card, item.pos);
                }
            });
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            updateAllCardPositions();
        }

        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>

